
1. есть ссылка и коллекция ссылок, которые могут ссылаться на ссылку или коллекцию ссылок
     при копировании ссылки создается новая связь(связи для коллекции)
2. эти два объекта умеют восстанавливать своего владельца (полем которого являются)
3. если объект, на который ссылается ссылка, загружен, она хранит указатель 
   (на коллекцию ссылок внутри этого объекта), иначе -- ID этого объекта
   используется факт, что последние 3 бита указателя должны быть нулями
4. отношения между объектами хранятся в виде этих же ссылок
5. в каждом объекте есть коллекция ссылок, нужная для ссылания на него из других частей программы
6. имеется трекер:
  * умеет читать и писать объекты в БД
      измененные объекты пишутся в фоне в БД
  * хранящий соответствие ID уже загруженным указателям
      соответствие ID хранит в виде vector или map, 
      (в последнем случае хранит только загруженные элементы (оптимизация))
  * руководит выгрузкой (то есть удалением из памяти)
7. ID новому объекту присваивается в ленивой манере 
   (то есть когда этот ID нужен, в частности, когда выгружется)
8. Выгрузка объектов: выкидываем все объекты, не использовавшиеся с последнего обхода.
   следующий обход делать, когда из оставшихся объектов неиспользованными 
   (с момента последнего обхода) останется столько, сколько мы хотели выкинуть

TODO: 
создание индексированных полей (решает проблему поиска и сортировки)



Мысли (могло устареть):

каждый объект имеет ID и данные, в том числе ссылки на другие объекты (по ID)
каждый объект имеет 
данные могут быть быстро сериализоваться и десериализоваться
если объект подгружен, указатель на него получается из его ID, используя ассоциативный массив (черно-красное дерево)
когда один из объектов "разрешает" свою ссылку на другой объект (то есть указатель через ID превращает в указатель через указатель), объект, на который ссылаются, получает об это информацию (адрес ссылающегося объекта добавляется в односвязный список). при удалении объекта, на который ссылаются, он должен обнулить указатели во всех ссылающихся объектах. при удалении ссылающегося объекта, он должен исключить себя из односвязных списков тех объектов, на которых он ссылается

синхронизация с жестким диском:
при доступе к объектам (или их полям, пока не решил), если он не был до этого помечен, объект помечается, что его нужно сбросить на диск.
при этом его добавляют в односвязный список синхронизируемых объектов.
при каждом изменении, назависимо от того, был он помечен или нет, инкрементится глобальный счетчик
когда счетчик достигает большого числа -- объекты сбрасываются (лучше асинхронно, хотя не суть)

как разрешается ID (при запросе пользователя или ри разрешении ссылки от другого объекта):
для начала проверяем, не кончился ли лимит выделенной памяти.
если кончился -- удаляем какой-нибудь объект (ПРОРАБОТАТЬ)
далее читаем объект с диска, НЕ разрешаем в этот момент ссылок по ID, которые у него есть
добавляем его адрес в дерево

как удаляется объект:
см выше
+ чистится дерево


ID и указатель могут храниться вместе: используя факт, что последний бит указателя равен 0


не const bool-функции во всех случаях возвращает true, если объект был изменен

при удалении из вектора перетащить последний элемент на эту позицию, так как не важно.
(сделать это поведением по умолчанию, но оставить возможность сохранить порядок)


------------------------------------------------------------------------

Классы:


BaseLink -- указатель на что угодно
BaseLinkSet<bool ordered=false, bool multi=false, typename Container=vector>
	содержит Container из BaseLink.
	ordered -- хранит порядок, в котором элементы добавлялись
	multi -- позволяет хранить ссылку на один и тот же элемент несколько раз
		в этом случае может ссылаться только на BaseLinkSet
Inner<FROM, from_field>
	объект, который умеет восстанавливать внешний по отношению к нему объект
Reference<typename FROM, from_field, typename TO, to_field, typename LINK_FROM, typename LINK_TO>
	LINK_FROM и LINK_TO -- BaseLink или BaseLinkSet
	наследуется от LINK_FROM и от Inner<FROM, from_field>
	* умеет получать указатели на LINK_TO, на который(ые) ссылается
	* возвращает указатели на Reference<TO, to_field, FROM, from_field, LINK_TO, LINK_FROM>
Relation<typename FROM, from_field, typename TO, to_field, typename LINK_FROM, typename LINK_TO>
	наследуется от Reference
	служит для хранения отношений между объектами
InnerLinkSet<typename FROM>
	наследуется от Reference<FROM, -1, ExternalPointer, -1, BaseLinkSet, BaseLink>
	возвращает указатели на ExternalPointer<FROM>
	входит в все модели и служит для хранения указателей на этот объект на время сессии
ExternalPointerMember<typename TO>
	наследуется от Reference<ExternalPointer, -1, TO, -1, BaseLink, BaseLinkSet>
ExternalPointer<typename TO>
	содержит ExternalPointerMember<typename TO>
	вложенность нужна для использования Reference
	служит для ссылания на объекты из не объектов
	умеет получать указатели на InnerLinkSet<TO>
ExternalCollection<typename TO>
	содержит интерфейс к vector из ExternalPointer
	если объект, содержащийся в коллекции, был удален, его ExternalPointer = 0
	ExternalCollection отслеживает такие ситуации и "перескакивает" через такие ситуации.
BaseModel<T>
	базовый тип для всех моделей
	тип T наследуется от BaseModel<T>
	T должен иметь метод persist (см Wt::dbo)
	содержит InnerLinkSet<T>. его активация происходит макросом
	содержит поле ID
		если создан и ещё не сохранен на диск, оно равно 0
		при попытке определить ID сохранятеся на диск, после чего его получает
	в качестве статического члена имеет ModelTracker<T>
	
ModelTracker<T>
	трекер для объектов одного типа
	T -- то же, что и в BaseModel (например, User)
		T имеет ID и persist
	имеет статический указатель на Tracker, определяемый во время компилляции
	умеет по запросу считывать и записывать в БД объекты	
	
Tracker
	хранит Connection, Session
	
если from_field == -1, то такой случай должен разбираться отдельно
(специализация шаблона)

размер всех ссылок (Reference) для случая BaseLink равен размеру указателя
для ExternalPointer возможно копирование, сопровождаемое созданием новых связей
копировать Relation или InnerLinkSet нельзя
деструктор Relation вызывает unload
деструктор ExternalPointer вызывает erase
деструктор InnerLinkSet вызывает unload
для Reference<LINK_FROM=BaseLink> и ExternalPointer определено ->, 
	возвращающее объект модели, на который ссылаются

typedef Reference<FROM, from_field, TO, to_field, BaseLink, BaseLink> 
	O2O<FROM, from_field, TO, to_field>;
typedef Reference<FROM, from_field, TO, to_field, BaseLink, BaseLinkSet> 
	M2O<FROM, from_field, TO, to_field>;
typedef Reference<FROM, from_field, TO, to_field, BaseLinkSet, BaseLink> 
	O2M<FROM, from_field, TO, to_field>;
typedef Reference<FROM, from_field, TO, to_field, BaseLinkSet, BaseLinkSet> 
	M2M<FROM, from_field, TO, to_field>

Методы BaseLinkSet:
	bool search(BaseLink) -- проверяет вхождение

Методы BaseLink:
	BaseLink можно сравнивать с другим BaseLink с помощью ==

Методы Inner:
	host() -- возвращает указатель на объект, содержащий этот Inner

Методы BaseLink и BaseLinkSet (указатели везде тут BaseLink или BaseLinkSet) 
	unload_simple(указатель, ID) -- исправиль указанный указатель внутри себя на соответствующий ID
	load_simple(указатель, ID) -- обратное к unload_simple
	erase_simple(указатель или ID):
		BaseLink: установить соотв. указатель или ID на NULL
		BaseLinkSet: удалить соотв. указатель или ID на NULL из себя
			если ordered=false, последний элемент становится на место удаленного
			если ordered=true, происходит сдвиг, чтобы сохранить порядок следования
			в случае multi=true, удаляется одна связь, а не все
	set_simple(указатель или ID) -- для BaseLink устанавливает его смотрящим на это
		для BaseLinkSet, добавляет элемент к списку

Методы Reference: (тут указатели на объекты модели, на которую ссылаются)
	эти методы работают не только с своим объектом, но и 
	с принимающей ссылкой того, на который ссылаются
		unload() -- превращает все указатели в ID
		erase() -- обнуляет все ID/указатели или удаляет их в случае BaseLinkSet
		erase(указатель или ID) -- исключает из себя этот элемент (для BaseLinkSet)
		set(указатель или ID) -- налаживает связь с этим элементом
			если LINK_TO=BaseLink, то сначала вызывает у Reference этого элемента erase (если был установлен)
		load() -- загружает объект(ы), на которые ссылается, устанавливает указатели
		load(ID) -- (для BaseLinkSet) загружает объект с таким ID


Методы Reference:
	Reference<LINK_FROM=BaseLink> с одинаковым TO можно сравнивать с помощью ==
		сдвиг при этом вычисляется внутри, если они в состоянии указателей
	Объявление функций в Reference:
		у Reference<LINK_FROM=BaseLink> можно узнать ID, на который она ссылается
		у Reference можно узнать ID её объекта
		ID у ExternalPointer равен 0 (и его никто не должен спрашивать)
	Reference<LINK_FROM=BaseLinkSet> можно итерировать, 
		элементы представляются как указатели на Reference<LINK_FROM=BaseLink>




пользовательский код:

	class User : public BaseModel<User>
	{
	public:
		enum Relations
		{
			r_referal,
			r_invited
		};
		int age;
		std::string name;
		M2O<User, r_referal, User, r_invited> referal;
		O2M<User, r_invited, User, r_referal> invited;
		
		template<class Action>
		void persist(Action& a)
		{
			dbo::field(a, age, "age");
			dbo::field(a, name, "name");
			dbo::field(a, referal, "referal");
			dbo::field(a, invited, "invited");
		}
	}
	// macro...
	
	ExternalPointer<User> user = new User();
	user->age = 99;
	user->name = "foo";
	
	ExternalPointer<User> user1 = new User();
	user1->age = 98;
	user1->name = "bar";
	user1->referal = user;
	
