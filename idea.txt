каждый объект имеет ID и данные, в том числе ссылки на другие объекты (по ID)
данные могут быть быстро сериализоваться и десериализоваться
если объект подгружен, указатель на него получается из его ID, используя ассоциативный массив (черно-красное дерево)
когда один из объектов "разрешает" свою ссылку на другой объект (то есть указатель через ID превращает в указатель через указатель), объект, на который ссылаются, получает об это информацию (адрес ссылающегося объекта добавляется в односвязный список). при удалении объекта, на который ссылаются, он должен обнулить указатели во всех ссылающихся объектах. при удалении ссылающегося объекта, он должен исключить себя из односвязных списков тех объектов, на которых он ссылается

синхронизация с жестким диском:
при доступе к объектам (или их полям, пока не решил), если он не был до этого помечен, объект помечается, что его нужно сбросить на диск.
при этом его добавляют в односвязный список синхронизируемых объектов.
при каждом изменении, назависимо от того, был он помечен или нет, инкрементится глобальный счетчик
когда счетчик достигает большого числа -- объекты сбрасываются (лучше асинхронно, хотя не суть)

как разрешается ID (при запросе пользователя или ри разрешении ссылки от другого объекта):
для начала проверяем, не кончился ли лимит выделенной памяти.
если кончился -- удаляем какой-нибудь объект (ПРОРАБОТАТЬ)
далее читаем объект с диска, НЕ разрешаем в этот момент ссылок по ID, которые у него есть
добавляем его адрес в дерево

как удаляется объект:
см выше
+ чистится дерево


ID и указатель могут храниться вместе: используя факт, что последний бит указателя равен 0


не const bool-функции во всех случаях возвращает true, если объект был изменен

при удалении из вектора перетащить последний элемент на эту позицию, так как не важно.
(сделать это поведением по умолчанию, но оставить возможность сохранить порядок)







BaseLink -- указатель на что угодно
BaseLinkSet<bool ordered=false, bool multi=false, typename Container=vector>
	содержит Container из BaseLink.
	ordered -- хранит порядок, в котором элементы добавлялись
	multi -- позволяет хранить ссылку на один и тот же элемент несколько раз
		в этом случае может ссылаться только на BaseLinkSet
Link<typename LINK_FROM, typename LINK_TO>, LINK_FROM и LINK_TO -- BaseLink или BaseLinkSet
	содержит LINK_FROM
	умеет получать указатели на LINK_TO, на который(ые) ссылается
Inner<FROM, from_field>
	объект, который умеет восстанавливать внешний по отношению к нему объект
InnerLinkSet<typename FROM>
	наследуется от Link<BaseLinkSet, BaseLink> и от Inner<FROM, -1>
	возвращает указатели на ExternalPointer<FROM>
	входит в все модели и служит для хранения указателей на этот объект на время сессии
ExternalPointer<typename TO>
	наследуется от Link<BaseLinkSet, BaseLink>
	служит для ссылания на объекты из не объектов
	умеет получать указатели на InnerLinkSet<TO>
Relation<typename FROM, from_field, typename TO, to_field, typename LINK_FROM, typename LINK_TO>
	наследуется от Link<LINK_FROM, LINK_TO> и от Inner<FROM, from_field>
	возвращает указатели на Reference<TO, to_field, FROM, from_field, LINK_TO, LINK_FROM>
	служит для хранения отношений между объектами

размер всех ссылок (Reference) для случая BaseLink равен размеру указателя
для ExternalPointer возможно копирование, сопровождаемое созданием новых связей
копировать Reference или InnerLinkSet нельзя
деструктор Relation вызывает unload
деструктор ExternalPointer вызывает delete
деструктор InnerLinkSet вызывает unload
для Relation<LINK_FROM=BaseLink> и ExternalPointer определено ->, возвращающее объект модели

typedef Reference<FROM, from_field, TO, to_field, BaseLink, BaseLink> 
	O2O<FROM, from_field, TO, to_field>;
typedef Reference<FROM, from_field, TO, to_field, BaseLink, BaseLinkSet> 
	M2O<FROM, from_field, TO, to_field>;
typedef Reference<FROM, from_field, TO, to_field, BaseLinkSet, BaseLink> 
	O2M<FROM, from_field, TO, to_field>;
typedef Reference<FROM, from_field, TO, to_field, BaseLinkSet, BaseLinkSet> 
	M2M<FROM, from_field, TO, to_field>


Методы BaseLink и BaseLinkSet
	unload_simple(указатель, ID) -- исправиль указанный указатель внутри себя на соответствующий ID
	load_simple(указатель, ID) -- обратное к unload_simple
	delete_simple(указатель или ID):
		BaseLink: установить соотв. указатель или ID на NULL
		BaseLinkSet: удалить соотв. указатель или ID на NULL из себя
			если ordered=false и Container!=list, последний элемент становится на место удаленного
			если ordered=true, происходит сдвиг, чтобы сохранить порядок следования
			в случае multi=true, удаляется одна связь, а не все
	set_simple(указатель или ID) -- для BaseLink устанавливает его смотрящим на это
		для BaseLinkSet, добавляет элемент к списку
		у BaseLink в случае, если до этого был установлен, сначала делает delete

Методы Link:
	unload() -- вызвать unload_simple() у (всех членов) себя 
		и у соответствующих членов по другую сторону связи(связей)
	delete() -- вызвать delete_simple() у (всех членов) себя 
		и у соответствующих членов по другую сторону связи(связей)
	delete(указатель или ID) -- вызвать delete_simple(указатель или ID) у себя 
		и у соответствующих членов по другую сторону связи(связей)
	set(указатель или ID) -- вызвать set_simple(указатель или ID)
		и set_simple(this) у соответствующих членов по другую сторону связи(связей)
	load(указатель, ID) -- вызывает load_simple(указатель, ID) у себя 
		и load_simple(this, ID) у соответствующих членов по другую сторону связи(связей)

Методы BaseLinkSet:
	bool search(BaseLink) -- проверяет вхождение

Методы BaseLink:
	BaseLink можно сравнивать с другим BaseLink с помощью ==
	
	
Методы Inner:
	host() -- возвращает указатель на объект, содержащий этот Inner

